\newcommand{\sysname}{Holmes}
%Scope Statement
%tl;dr I want to deal with the interaction of binary analyses
This thesis is focused on the interleaving, interaction, and scheduling of analyses over binary code.
%Compiled code, sans source, is everywhere
Software, whether it is in the form of Dalvik code on an Android device, a game downloaded from a digitial distribution platform, a disc purchased in a traditional brick and mortar store, or even the firmware on a router, tends to come in the form of a compiled binary sans source.
%Compiled code needs to be analyzable
%BUG: there's no explicit customer, and that's kind of a dodge. What's the real answer?
%BUG: My actual goals here are to be able to poke around inside a binary, usually to develop attacks. However, attack dev is probably not PC, gotta come up with something else. Possible ideas:
% * Security audits of code - possible viewpoints:
%   * Third party libraries?
%   * Consumer audit? (seems unlikely)
%   * Security firm audit?
% * Malware detection, ala VET. Possibly don't want to list this to avoid bringing adversarial attackers into scope
% * Generating attacks. This may not be entirely within the "good" model, but may be acceptible in the modern day?
This software needs to be analyzable in order to allow for security audits of code.
%This is difficult because binaries are turing complete, and even "well behaved" code does crazy shit
%BUG: "ranging from" statement is kind of an e.g. but might seem limiting
Unfortunately, analysis of compiled code provides a number of unique challenges, due to the stripping away of information the original programmer had access to, ranging from intended control flow information to the types and locations of variables.
%General statement about how we can help?
The reconstruction of some or all of these lost abstractions from the code can help drastically with the ability to check or comprehend the artifact.

%Previous Work
%VSA
%Jakstab
%Types shit
Previous work in recovering abstractions from binary code has performed partial type recovery, function identification, variable identification, control flow recovery, and value analysis.
However, in each case, when one system depended on the results of another, the integration and ordering ends up tightly coupled.
In the case of one control flow recovery system, the dependency loop between their control flow recovery and their value analysis necessitates a tight loop between the two.
In general, one of the major weaknesses of this body of work is that these systems use results from each other, but each system only works with one question answered as an output, and acts as a standalone system.
These systems could all benefit from using each other's output to improve their results when possible, and from the ability to combine results of different methods for answering the same question.

%This is Holmes
\sysname\ is a logic language inspired by datalog with several features geared towards the ability to use a logic program as a means of coordinating several independent analyses.
%Features:
% Forwards + Backwards chaining
% Caching
% Remote user defined predicates
% Scheduling
% Combining
\begin{enumerate}
\item
By providing the ability to define external predicates via multiple input, multiple output functions over RPC, \sysname\ has the ability to leverage existing implementations and multiple distinct machines.
\item
\sysname\ mixes forwards and backwards chaining execution, defined per rule, to enable the rapid processing of things that will nearly always want to be done, such as lifting of reachable addresses to an intermediate language or stack-structure variable recovery, while allowing for goal-directed execution of longer procedures such as fuzzing runs or DIVINE variable recovery.
These per-rule planning hints form the beginning of scheduling rules that may have high execution time, or even potentially non-termination.
This method of binding analyses also provides a good notion of when it is potentially useful to re-run analyses in light of new information, as the coordinating logic program knows exactly which information was passed to the remote function.
\item
\sysname\ provides a mechanism for registering combining functions for related facts.
For example, if one value analysis provides $\{1, 2\}$ as a lower bound on the value of a register, and another provides $\{2, 3\}$, selection of a union as the combining function would allow other analyses to receive $\{1, 2, 3\}$ as the lower bound.
\item
The logic language representation of knowledge provides a good way to deal with the partially determined information that tends to be imparted by program analyses. As more data shows up, the dependencies in the rules make it explicit which things need to be recomputed for additional information, and which did not require any.
\end{enumerate}

%Work Plan
\sysname\ provides a way to mesh the many existing styles of analysis together, taking into account the potential for nontermination or high cost of various analyses. This thesis will provide semantics for the \sysname\ language, an implementation of a program which actually runs the language, and example applications coordinating multiple analyses to achieve better results than they could achieve alone. If all goes well, methods of circumscription in non-terminating or scheduled environments will be examined for their applications to binary analysis.
