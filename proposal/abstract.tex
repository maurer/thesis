%Scope Statement
%tl;dr I want to deal with the interaction of binary analyses
This thesis is focused on the interleaving, interaction, and scheduling of analyses over binary code.
%Compiled code, sans source, is everywhere
Most commercial software tends to come in the form of a compiled binary sans source.
%Compiled code needs to be analyzable
This software needs to be analyzable in order to allow for security audits of libraries and executables, continued use of legacy code, and attack development.
%This is difficult because binaries are turing complete, and even "well behaved" code does crazy shit
Analysis of compiled code provides a number of unique challenges due to the stripping away of information the original programmer had access to, such as intended control flow information, types, and variable locations.
%General statement about how we can help?
A wide variety of techniques for attacking this problem from different angles have been developed, but are typically resource intensive and not integrated with one another.

%Previous Work
%VSA
%Jakstab
%Types shit
Previous work in analyzing binary code has performed type recovery\cite{bitr}, variable identification\cite{divine}, control flow recovery\cite{jakstab,phoenix}, and value analysis\cite{vsa}.
However, this work tends to have issues with the relative expense of running the analyses, the coupling between analyses, and the integration of the current state of the art in each area.
While many interesting analyses have been developed, cooperation and integration of these analyses has been largely ignored.

%This is Holmes
I intend to build \sysname, a logic language inspired by Datalog with several features geared towards the ability to use a logic program as a means of coordinating several independent analyses.
%Features:
% Forwards + Backwards chaining
% Caching
% Remote user defined predicates
% Scheduling
% Combining
By providing the ability to expose external functions to the language, and allowing them to transform bound variables during rule execution, \sysname\ will allow the use of other paradigms and languages for writing analyses.
Binding analyses to rule firing also allows the framework to provide caching, re-running analyses only when needed.
\sysname\ will mix forwards and backwards chaining execution, defined per rule, to enable the rapid processing of things that will nearly always want to be done, such as lifting of reachable addresses to an intermediate language, while allowing for goal-directed execution of longer procedures such as fuzzing campaigns.
These per-rule planning hints form the beginning of scheduling rules which are costly or non-terminating.
\sysname\ will provide a mechanism for registering combining functions for related facts to a subsuming fact for simpler reasoning about accumulated information.
The logic language representation of knowledge provides a good way to deal with the partial information that tends to be imparted by program analyses. As more new facts are generated, the dependencies in the rules make it explicit which rules can use the new information.

%Work Plan
\sysname\ provides a way to mesh the many existing styles of analysis together, taking into account the potential for nontermination or high cost of various analyses. This thesis will provide semantics for the \sysname\ language, an implementation of a program which actually runs the language, and example applications coordinating multiple analyses to achieve better results than they could achieve alone.
