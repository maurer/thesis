\section{\sysname\ Basic}
\label{sec:holmesBasic}
Initially, I will aim to implement a more basic set of features in \sysname.
This feature set is intended to be complete enough to pursue the majority of the application work, while simple enough that its completion should not be in question.
In the basic version of \sysname, I will implement a system with:
\begin{itemize}
\item Forwards and backwards chaining
\item Simple external predicates
\item Result caching/persistence
\item Combination functions
\end{itemize}
Additionally, I will formalize the semantics of the restricted system.

While the actual system will operate based on RPC calls, it is conceptually useful to think about the system in terms of a written out set of rules.
In Figure~\ref{fig:holmesGrammar}, I depict a draft of what this would consist of for \sysname\ Basic.
Additional constraints are necessary beyond what is expressed in the grammar (e.g. variable occurrence restrictions), but this gives the basic concept for the moment.
The only thing not directly expressible in this language is the external functions themselves.
External functions creation is not given a representation here because they are represented to the system by providing it with an RPC handle, and so they act as black boxes;
to provide a direct means of expressing them would be misleading about what the system could reason about.

\begin{figure}
\begin{grammar}

<prog> ::= (<decl> | <rule>)*

<decl> ::= <pred> `(' <argsig>+ `)' [`where' (`(' <arg>* `)' `=' <expr>)]

<argsig>
::=  <type>(= : <func>)
\alt <type>($\oplus$ : <func>)

<rule> ::= <head-constr> <sched-sym> <body-clause>

<sched-sym> ::= $\leftarrow$
\alt $\Leftarrow$

<head-constr> ::= (<pred> `(' <expr>+ `)')+

<expr> ::= <var>
\alt <consnt>
\alt <func> `(' <expr>* `)'

<body-clause>
::=  `('<body-clause>`)' $\wedge$ `('<body-clause>`)'
\alt <pred> `(' <arg>* `)'

<arg> ::= $\exists$ \alt <var> \alt <const>
\end{grammar}
\label{fig:holmesGrammar}
\caption{\sysname\ Grammar}
\end{figure}

Ignoring external predicates for a moment, I expect the semantics of the basic system to resemble a Prolog with user annotated precomputation and caching.
One notable deviation is the lack of an implicit evaluation order.
While in Prolog this provides the programmer the ability to write terminating code, in \sysname it precludes the opportunity to explore scheduling of proof search.
A second deviation is the presence of combiners.
I suspect, but am not sure, that combiners will only have a minor effect on the actual execution of the language.
I believe the effect to be minor because the way combination happens means that matching on an improved combined fact will look identical to matching on a not-yet present uncombined fact.

The major sticking points in finalizing this system will probably be:
\begin{itemize}
\item {\bf Rule firing order.}

While forwards verus backwards chaining puts certain constraints on which rules can fire, this may need to be constrained further for a workable system.
I hope to leave it unconstrained, as this will make work on scheduling them more interesting, but it could easily be an issue.

\item {\bf External code binding.}

There is a lot of power to be gained once you start allowing function symbols to appear in certain places.
Initially, I am taking the approach that where clauses and scoping rules will allow me to search or fire rules in a way that only requires execution of functions.
However, this approach denies the ability to use unification and treat code as function symbols (e.g. by placing a function in the head of a backwards chaining rule).
I will need to decide on a precisely where functions can appear to allow my execution strategy to function.

\item {\bf Combiner subsumption.}

Since combiners are intended to be allowed to use external code, proofs of subsumption necessarily will not be fully formal.
However, knowing exactly which operations may be safely used against a combined field safely will likely be a tricky issue.
In simple cases, like sets combined via intersection, the result is obvious (you can ask if the value is a subset of a target set).
Indeed, for anything that lies on a lattice, the result for meet or join combiners is straightforwards.
In more complex cases, it may be unclear what queries are legal.
This will also help indicate under which circumstances circumscription becomes necessary;
when the user wishes to make a query not consistent with subsumption, they essentially must circumscribe in some way first.
\end{itemize}

Additionally, I intend to investigate what circumstances lead to terminating evaluation of the forwards chaining fragment.
Adding backwards chaining would prevent reasoning from the finite set of initial facts, and so make for an undecidable problem.
Even with only forwards chaining, this is potentially tricky.
Given variables which range over an infinite domain, properties are required on the external predicates to guarantee termination.
Knowledge of what properties these are would assist future programmers of this system in designing preprocessing phases for their applications.
\section{\sysname\ Advanced}
Possible additional topics to explore as they are relevant to applications include:
\begin{itemize}
\item Retraction - removal of facts or even rules from a live system with minimal perturbation to support hypothetical analyses
\item Circumscription - reasoning as though knowledge of some fact is all you will ever have/can be known, despite not knowing this for certain
\item Tactical Evaluation - adaptation of a system similar to Coq's tactic scripts to suggest evaluation strategies
\item Learning Evaluation - self improvement of evaluation strategies based on past success and cost of external predicates
\item Resource Constrained Evaluation - Getting the best answer within certain time/machine constraints
I intend to hit at least some of these as I explore the usefulness of this system to binary analysis, but not necessarily all of them.
\end{itemize}
