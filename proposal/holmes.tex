% Overview
% * Binary analysis information as facts in a deductive database
% * Traditional logic language approaches treated the logic language as an analysis module in a larger scheme
% * Use the logic language to integrate other analyses, treating external code as where-clause-functions (analogous to external predicates)
% * Use monotonic aggregators (secref) to enable functions to consume 'all' of something monotonically
% * Use hypothetical circumscription (secref) to enable functions to consume 'all' of something in a non-monotonic way, while still allowing the database to maintain a monotonic view
% * Use explicit backwards chaining to enable expensive or nonterminating functions (esp. fuzzing) (secref)
% * Implement system in a way that is efficient and will scale to large datasets (secref)

% Monotonic Aggregators
% * Why does external code need this? (TODO explicit example)
% * Definition (see agda in contributions localfile)
% * Set-bound examples
% * Abstract interpretation example (bounded intervals)

% Hypothetical Circumscription
% * Why do we need this? (CFG example)
% * Definition (reveal domain explicitly)
% * Why is this circumscription? (Minimizing the extent of a given pattern)
% * Why is this hypothetical? (It is possible we will receive future evidence suggesting the minimum extent is larger)
% * Why does revealing the domain constitute this?
%   * At least as powerful because we could use list union + any query + this to get explicit membership
%   * At most as powerful because we could fold over membership to produce the given domain
%   * It could be more powerful if order-indep wasn't a property on aggregators
% * Call-CC
%   * Why do we need this extension? (CFG->CFG example)
%   * Simplified 1,2,3 -> 1,2,3,neg4 -> 1,2,3,neg4,4 -> 1,2,3,4 example
%   * Why is this call-CC?
%   * Why can we do "bag" circumscription (e.g. circumscribe neg4 and neg5 "simultaneously" and pick one to break out on)

% Bidirectional Proof Search
% * Forwards chaining = datalog
%   * Want this to represent things which
%     * Almost always need to be done
%     * Can be done efficiently
%     * Have a reasonably bounded extent
%   * Good for preprocessing/directed auto-analysis
%   * Examples
%     * Parse
%     * Lifting
%     * Initial CFG
%     * Loaded memory image
% * Backwards chaining = prolog
%   * Want this to represent things which
%     * Rarely need to be done
%     * Have an enormous or infinite extent
%     * Are potentially expensive
%   * Good for directed queries from a user
%   * Examples
%     * Fuzz
%     * Solve this function for stack overflow with symex + smt
%     * TODO more examples
% * Execution strategy
%   * Queries / rule firing acts as a transaction, multiple may be in flight
%   * Try to fire any legal forwards chaing rules until quiescence
%   * If a query is received
%     * Output known matches
%     * Do a backwards search (strategy tbd), treating forwards rules as backwards rules
%     * Commit results of backwards search to database and output

% Implementation Strategy
% * Lang = rust
%   * Safe
%   * Efficiently handles large data
%   * Threading story
% * Database engine = postgres
%   * Transactions (multiple rules in flight)
%   * Joins (avoid writing a custom query compiler for match terms, just compile to joins)
%   * Efficient jsonb support for custom user data structures
% * RPC system = Cap'n'proto
%   * Efficiently handles large data
%   * Encoding of structured data for user types
%   * Supports "sturdy refs" for resuming analysis services
%   * Multilang support (python, rust, C++, js, partial ocaml)
% * See impl in progress at my github
