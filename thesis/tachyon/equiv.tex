\section{System Call Stream Deviation Detection and Rewriting}
\label{tach:sec:equiv}

Patches often add, delete, or modify  new system calls in the original
buggy program.  Our example in Listing~\ref{tach:lst:example} shows all
three cases.  When the streams of syscalls differ, then the two programs are
semantically different.  While this means we cannot automatically tell
if the differences are meaningful, we can (a) automatically detect
deviations and (b) rewrite deviations when informed by the user that
the semantic differences are permitted. The heart of detection and
rewriting is \tachyon's syscall stream matching and rewriting engine.

% When the syscalls change between$\patched$ and
% $\unpatched$, then 

% Since the patch introduces semantically different I/O, it is
% impossible to automatically decide whether the changes are
% inconsequential or not. However, we can (a) automatically
% \emph{detect} 

% Naively, you might expect that pre and post-patch programs will always
% issue the same set of system calls on normal inputs.
% Unfortunately, this is not the case.
% For example, if a program changes the size of the
% buffer in a bulk transfer from 1024 to 4096, this will
% cause a change in the system call stream (fewer read/write calls), while causing
% little or no change in the effects.

\subsection{Stream Matching}

\tachyon uses a rule-based system for rewriting
system call streams during execution, designed to be employed by a
user of the tracing software to explain to the system what behaviors
it should consider equivalent. The rules must consume a sequence of system calls by
$\patched$, and produce a corresponding set of system calls for $\unpatched$ to
make in order to allow for writing call results into $\unpatched$ and checking
that $\unpatched$ indeed matches the particular equivalence rule.

As we execute, we have two streams of tuples. \tachyon represents the
stream from $\patched$ as $\tuple{C_i}{\vec{I}_i}{\vec{O}_i}$, and the
stream from $\unpatched$ as $\tuple{C'_i}{\vec{I}'_i}{\vec{O}'_i}$.
The easy case is when the two programs are semantically equivalent by
issuing the same system calls, i.e., $\forall i: C_i = C'_i \land \vec{I}_i = \vec{I}'_i$.  In this case no rule is needed, and
\tachyon will send the corresponding $\vec{O}_i$ for each $\vec{I}_i$ to $\unpatched$.

Any time the syscall input arguments do not line up, \tachyon reports a
semantic deviation.  In order to permit some deviations, \tachyon
provides the ability to rewrite the system call stream.  The rewrite
engine takes in a set of rewriting rules $f$.  Each rewrite rule $f_k$
is a function which takes in $\tuple{C_i}{\vec{I}_i}{\vec{O}_i}$ and
$\langle C_i', \vec{I}'_i \rangle$. 
The rule uses pattern matching
to decide if it applies, and if so, returns a pair of equivalent syscall
streams to perform a substitution with.
After a
match, the stream continues to be consumed by the simulated program $\unpatched$. 

% In the simplest case, each sub-stream is of length 1, and so we
% get a deletion sub-stream that looks like
% $\tuple{C_i}{\vec{I}_i}{\vec{O}_i}$, and an insertion sub-stream that
% looks like $\tuple{C'_i}{\vec{I}'_i}{\vec{O}'_i}$, where $\vec{O}'_i$
% is generated by the function in question.

The overall mechanism can be used for:
\begin{itemize}
\item Determining roughly equivalent  syscalls, e.g., many small
  writes being patched to be one big rewrite.
\item Ignoring syscalls, e.g., the $\patched$ program issues a call
  that is not needed by $\unpatched$. 
\item Limited reordering, e.g., allowing for syscalls to be switched.
\end{itemize}


%\edissue{You suggested this section needed to be rewritten for clarity. Have these changes done the trick?}


\subsection{Rewriting Rules}

Each rewrite rule $f$ takes a system call (the one made by $\patched$)
and the input to a potential system call made by $\unpatched$, and
returns a substitution in the stream. The substitution is implemented
as a pair of lists, where the left list indicates the syscalls
consumed by the rule, and the right list indicates the corresponding
substitution produced by the rule.  The type signature for $f$ in
\tachyon is:
\[
\text{Syscall}  \impl \text{SysReq} \impl \text{Maybe ([Syscall],
  [Syscall])}
\]
\noindent where the ``$\text{Maybe}$'' indicates that the rule may also return that
no substitution was performed. 


The rewriting rules are pure functions, which means they have no
access to outside resources like the current syscall stream or
application state.  By being pure we ensure that rewrite rules can be
applied in any order.  In addition, it ensures that the rule engine
itself will not continually accumulate state, i.e., while individual
rewrites may take substantial space, the space used will remain
constant in the number of system calls which have gone through, which
is vital to an online system.


During execution, the matching engine maintains a queue of syscalls
executed by the live program $\patched$.  Suppose the queue contains
any syscall $x$ that is not \texttt{write}, but the simulated program
$\unpatched$ issues a \texttt{write} syscall.  The simplest rule is to
ignore the \texttt{write}.  This is accomplished by adding a
\texttt{write} to the queue before $x$.  When the matching engine
re-examines the queue, it will match the still-pending \texttt{write} to the
one in the queue, and not report a deviation.

In \tachyon, the rule is written as:
\lstset{language=Haskell}
\begin{lstlisting}
ignoreWrite :: Syscall
            -> SysReq
            -> Maybe ([Syscall], [Syscall])
ignoreWrite x (Write 2 buf sz) =
  Just ([x],
        [Syscall (Write 2 buf sz) sz, x])
ignoreWrite _ _ = Nothing
\end{lstlisting}

This rule fires when line 4 is matched. This occurs when $\patched$
issues a syscall $x$ that doesn't match $\unpatched$'s syscall
\texttt{write}. On line 5 the rule directs it to consume whatever is
on the stream at the moment, and replace it on line 6 with the stream
of \texttt{Write} followed by $x$. This can be thought of as
``faking'' the call for \texttt{Write} to the stream matcher so that
it does not report a deviation. On line
7, we catch the case where our conditions are not met, and
indicate we did not modify the stream.

The simple, no-look-behind method of replaying with this equivalence
is to replay the stream normally until a match fails. At this point,
the two syscalls that failed to match are fed into all rewrite rules,
and their replacement list for the original stream is checked. If
there is still more than one rewrite rule remaining, one is chosen
arbitrarily. In future work, checkpointing could be used here to allow
for the ability to rewind if the wrong replacement was chosen.  In
practice, the rules we tested have only yielded one matching rewrite.

%In this way, we can safely describe a looser form of equivalence that
%still allows for the replaying of the new system call results to the
%program, and so allows us to continue the trace.


A more complex example is what we call write splitting, which occurs
when a larger write in the original program is translated into two smaller writes in the
replayed program. This is useful if the buffer size used in a
transmission was decreased during the patch, as it allows for a roughly
equivalent operation---writing one part of the message, then the other---to
be treated the same as the original system call writing the entire
message. A concrete example would the difference between the program fragments:
\begin{lstlisting}
-#define CHUNK 4096
+#define CHUNK 1024
 while(buf < end) {
   buf += write(fd, buf, min(end - buf, CHUNK));
 }
\end{lstlisting}

In the patched case here, we will see on average 4 times as many
system calls, but fundamentally, the same thing is happening. A
rewriting rule for write splitting says that a sequence of previous
writes can be used to fill on big write request:
\lstset{language=Haskell}
\begin{lstlisting}
writeSplit :: Syscall
           -> SysReq
           -> Maybe ([Syscall], [Syscall])
writeSplit (Syscall (Write fd buf sz0) sz) --sz is return size
           (Write fd' buf' sz')
 | (fd == fd')
  && (sz' < sz)
  && ((take sz' buf) == buf')
     = Just ([Syscall (Write fd buf sz0) sz],
             [Syscall (Write fd' buf' sz') sz',
              Syscall (Write fd' (drop sz' buf)
                                 (sz0 - sz'))
                        (sz - sz'))
writeSplit _ _ = Nothing
\end{lstlisting}

This rule states that if we have a write call in the original
stream, and the replayed program is trying to make a non-matching
write call, but it matches on the file descriptor, and has a smaller
size, and the write it is trying to make is a prefix of the original
write, then we can replace the original write with two smaller writes,
the first of which is the target write, and the second of which is set
up to represent the rest of the write.

In line 6, we do a sanity check that the file descriptors we are
writing to are the same, followed by a similar check in line 7 that
the request from $\unpatched$ has a smaller size than the original
form $\patched$. Finally, in line 8 we make sure that what is trying to be
written is a prefix of the appropriate length of the original write.
Given these conditions, we know that we can provide a replacement rule
which will allow the trace to proceed. In line 9, it tells its caller
to consume the most recent call, asserting that it matches the call
passed into us. In line 10, we see the first call that is going to end up
on the new stream, which matches the input vector we've received from
$\unpatched$, and so will allow the trace to continue. In the 11,12,
and 13, the function returns an additional item for the system call
stream, which represents the rest of the write that has been split.
In 14, we catch the case where we don't apply, and simply return no
pattern.


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
