\section{Architecture}
\label{tach:sec:impl}

\tachyon is built to target Linux for the x86-64 architecture via the
\texttt{ptrace} call, written in Haskell.  An abstraction barrier is
in place around \texttt{ptrace}, to ensure the technique's generality
and portability to other systems with similarly powered tracing
libraries.  Haskell was chosen for abstract data type support,
multi-OS portability, relative speed, and a monadic abstraction layer
that proved useful for our tracing environment.  

\paragraph{\texttt{ptrace}}
\tachyon uses the \texttt{ptrace} system call to accomplish system
interposition.  Use of \texttt{ptrace} starts with initialization, in
which options are set and the remote process either volunteers itself
for tracing, or is traced via a command to attach to its pid. Then,
\texttt{wait} and \texttt{wait4} are used in an event loop to get
status information about processes (which are paused when generating
one of these messages) and are then resumed at a later time.

The wakeup and sleep powers are implemented by selectively choosing to
not resume or resume threads at system call boundaries. While this
only enables us to support putting the currently running thread to
sleep, we never needed to stop any thread for which we were not
currently processing an event.

\paragraph{Trace Abstraction.}
The trace abstraction layer is designed to expose only primitives we
believe to be constructible on all platforms for portability purposes.
Additionally, the interface was higher level than the tracing
interface directly available on most platforms, enabling easier
authoring of the code. Fundamentally, a handler is provided for
events which the tracing interface detects and sends back. The potential
events currently supported are pre/post syscall, and process
split. Available to the callback is the ability to put threads to sleep,
wake them up, read and write registers, and read or write memory in
the target process.
\input{tachyon/multi}
\paragraph{Special Syscalls.} While in general the simulated application
$\unpatched$ uses the effects of syscalls from the live $\patched$,
\tachyon does have a few exceptions.  The exceptions occur when a
syscall result from $\patched$ cannot be emulated in $\unpatched$.
This usually occurs when there is something which is part of the thread
life cycle or virtual memory system, which are not facilities that can
be directly accessed by \tachyon.
Luckily, there are only a limited number of cases.

The first is \texttt{sbrk()}, which is the syscall responsible for
dynamic memory allocation. Luckily, this particular call can be passed
through, as it does not modify OS state, it only serves to modify the
process's VM system.

When a \texttt{clone()} occurs, we match input arguments like any other
system call, and then allow it through. \texttt{ptrace} feeds us an event
notifying us as soon as the new thread exists, and pauses that thread before
it can do anything so that we can attach to it. This event is also part of the
synchronized system call stream. \tachyon then registers that new thread and
its pair between emulated tid and real tid, and proceeds with normal operation.

The \texttt{exit\_group()} system call works like any other, except that it acts as
an end-of trace marker. We currently only accept full application exit, in which
all threads are simultaneously terminated, but there is no reason our techniques
could not be extended to individual thread destruction.

The most complicated is \texttt{mmap()}, which maps a file or device into
memory.  Our implementation depends upon the operations performed on
the region.  The read/write case would be extremely expensive to
monitor, as all writes are effects, so we would have to interpose
on every memory write to that page,
and so this case is disallowed entirely. It might be possible to deal with writable
mapped files or shared regions shared outside the program,
using page faults and slow execution, or some form of snapshot
trick. We leave this as future work.

In the read only case however, the translation is straightforward.
Rather than issuing the mapping as requested, we instead simply ask
for a private mapping of the same size this thread received during
recording, and fill that buffer with the contents that memory
contained after the initial map.
Private mappings of anonymous memory are also easy to support, and are
be simply passed through.
Finally, in the case of shared memory, we can allow it if it is both
anonymous and our multithreading system is in place. This could be
extended to allow for non-anonymous shared memory by spawning fake
file descriptors to the region, but is left as future work.

Other system calls for which we would need to add special implementation
to allow them to be serviced by the kernel, but still safely matched include
\texttt{munmap}, \texttt{mprotect}, \texttt{fork}, \texttt{sigaction},
\texttt{sigreturn}, and \texttt{exit}. These were unneeded for our test cases
and were not implemented.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
