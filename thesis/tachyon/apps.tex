\subsection{Applications}
\label{tach:sec:apps}
There are a wide variety of purposes this technology could be used for. We
have primarily targeted patch verification, but it can also be used for
debugging, crash reporting, and running honeypots.
\subsubsection{Live Patch Testing}
This is the main application we have been describing throughout the chapter.
Here, there are have two main possibilities - either the primary
objective is in making sure all services operate as they have,
or the primary goal more is more concerned with keeping those services secure.
In the case where it is desired to keep all services as they are,
the patch is run in tandem as the untrusted/isolated software under the
tracer. Any divergences can be analyzed by a human to classify them
as either semantic differences, and thus reasons to reject the
vendor patch, or security issues (e.g., a shell was executed),
and thus it was likely a mistake to not apply the patch earlier, but
the entry point is at least known.
If instead it is desired to keep things as secure as possible, but wish
to watch for incompatibilities, for example to make sure to deal with them
in dependent systems, the patched version is run as trusted, and run
the old unpatched version as the unpatched version in tandem.
\subsubsection{Honeypots}
\label{tach:sec:honeypot}
If such a tracer is deployed on a mostly stable piece of software
which will execute much the same system calls on the same inputs across
versions, the administrator can use it to detect someone attempting to launch an
exploit against vulnerabilities the system is already patched against. Run the
modern/believed safe binary as trusted, and stream the syscalls to
as many old versions as use a syscall equivalent IO strategy. Then,
if they would have exploited any of the old versions, a divergence will
be detected, and a dump can be created.

In this way, a safe honeypot can be run on live data, in a real
situation. This mitigates one of the traditional honeypot issues, which
is their identifiability as such. To all outside appearances, software
deployed in this fashion will appear exactly as though it were a real
target, because it is.

Additionally, in some cases it may lend an extra edge in the security of
the system in question. This would also allow this honeypot to identify a subset of
attacks against the new binary. Specifically, if older revisions are
not vulnerable, divergence will occur.
\subsubsection{Debugging}
One of the most difficult to debug classes of bugs is commonly known as
heisenbugs. These are bugs which will seemingly randomly occur or not
occur with all of the inputs the programmer knows about held constant.
These traces, and the associated replay mechanism, provide a way to step
through the program in a completely deterministic way, so that once
a heisenbug has been caught with tracing on, it has been captured and
the sequence leading to it can be carefully explored and debugged.
As we capture all inputs, the programmer doesn't have to keep guessing
at what factor has not been accounted for. Our deterministic thread
interleaving (up to sync points) similarly helps for the repeatability
of debug traces, making it easier to pinpoint and work on a single
scenario at a time.
\subsubsection{Crash Reporting}
While not suitable for most final deployments, as the trace would get
rather big, one could imagine alpha-grade software shipping inside a
trace recorder. In the event of a crash, the trace would be written out
to disk, and could be shipped back to the developers if the user wished
to. This would allow the developers to get their hands on an exact
execution. They would not need to attempt to replicate system settings,
profiles, or other environmental factors to replicate the user problem.
The crash dump itself would be sufficient to go to any point in the
execution from program launch to the time of crash.
