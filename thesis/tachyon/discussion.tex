\section{Discussion}
\label{tach:sec:discussion}

\paragraph{Other Patch Testing Scenarios.} While throughout this paper we have focused on online patch testing
where the patched version is run live, we could also run the unpatched
version live.  We note that the live program can continue executing
after a deviation, but currently the syscall sync application cannot.
Thus, by running the patched live, we are assuming that after a
deviation the right thing is to continue executing the patched
version.  However, by running the  unpatched version live, we can
check for incompatibilities while allowing for the original program to
continue executing after a deviation.

\paragraph{Honeypots.} \tachyon can also be used as a type of
lightweight honeypot. Let $\patched$ be a patch for a security
vulnerability, and $\unpatched$ be the vulnerable program. Observe
that $\patched$ and $\unpatched$ differ on exploits by definition.  By
running $\patched$ and $\unpatched$ in-tandem, \tachyon will report a
deviation on attacks.

A clever approach to running a honeypot is to run $\patched$ as the live
program, with $\unpatched$ as the sync. In this setting an attacker
only seeing the buggy program. \tachyon will report attacks, e.g., by
logging a deviation when shellcode tries to execute \texttt{/bin/sh}.
However, the system is safe from a real compromise because \tachyon
can be configured to abort execution after the deviation.



\paragraph{Debugging.} One of the most difficult to debug classes of
bugs is commonly known as heisenbugs. These are bugs which will
seemingly randomly occur or not occur with all of the inputs the
programmer knows about held constant. These traces, and the
associated replay mechanism, provide a way to step through the program
in a completely deterministic way, so that once a heisenbug has been
caught with tracing on, it has been captured and the sequence leading
to it can be carefully explored and debugged. As we capture all
inputs, this also makes it possible for the programmer to debug a
crash that took place on another machine, without having to try to
replicate the OS state to reproduce the crash.

\paragraph{Efficiency.}
Recall \tachyon uses user-land syscall interposition, and has
our approach to syscall interposition as its primary source of overhead
Currently, interposing on each system call on the live program requires 4
context switches. \tachyon context switches from $\patched$ to the
kernel, from the kernel to \tachyon, from \tachyon back to the kernel,
and finally back to $\patched$. Normal operation only has two context
switches: from user to kernel space, and back again.  A kernel-space
interposition scheme would also have only two switches. 

Recall from \S~\ref{tach:sec:eval} the overhead from copying data is almost
linear in the amount data transferred between $\patched$ and
$\unpatched$. A basic in-kernel approach would still have a linear
overhead (since data has to be copied into both virtual memory
spaces), but likely with a smaller constant factor.

Our user-land approach was chosen because it offers a clean separation
of functionality, isn't kernel dependent, and offers an easier
development environment.  Moving the system call interposition into
the kernel would not have these advantages, but would likely improve
performance. We leave further study of in-kernel tandem execution schemes
as future work.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 

