\input{formal/syms}
\chapter{Formal Holmes}
\label{chap:formal}
Holmes differs from base Datalog in callbacks (analogous to external predicates), aggregates, circumscription, and call/cc.
External predicates already have a well understood semantics, and we will model callbacks as interpreted functions by extension of our Herbrand universe during instantiation (\S \ref{formal:sec:callbacks}).
Aggregates in the presence of interpreted functions can be replaced by a syntactic transformation, other than for purposes of circumscription.
Adding call/cc forces a solution to exist when it otherwise would not, adding a restricted set of solutions which violate the minimality constraint of stable set semantics when no stable set exists.

We will first go over the negation model embedded at base Datalog to demonstrate how it works more clearly (\S~\ref{formal:sec:negation}).
Then, we will show how to construct the Herbrand universe for a program with callbacks, aggregates, and circumscription (\S~\ref{formal:sec:herbrand}).
Finally, I will give semantics for the Herbrand instantiation of a Holmes program which interprets circumscription as infinite negation, and call/cc as the failure of one of those negated terms (\S~\ref{formal:sec:semantics}).
%TODO add any proofs to intro
\section{Negation}
\label{formal:sec:negation}
\subsection{Other forms of Negation}
The first primary distinction to draw in negation is ``strong negation'' vs ``negation-as-failure'', or NaF.
Strong negation describes having knowledge that something is not the case, whereas NaF describes knowing that we will never have proof that something is the case.
This difference is more formally defined by Gelfond and Lifshitz~\cite{strongneg}, where strong negation is referred to as classical negation.
In this work we will focus on negation-as-failure.

One way of interpreting negation is ``stable-set'' semantics~\cite{stablemodel}.
In stable-set semantics, to check a whether a proposed model is a stable set, we first take the reduct of the logic program under the proposed model.
To do this, we remove all negated body clauses which are not present in the proposed model (and so are satisfied), and then remove all rules which still have negated clauses in them (which were not satisfied).
If the model is the minimal model of this reduct (this new reduced program), then it is a stable set, or stable model of the program.
This interpretation admits an arbitrary number of potential stable models, including none.

Another approach is known as ``well-founded negation''~\cite{wellfounded}.
This approach constructs what it calls ``unfounded sets'', which are sets of values which, relative to a given partial interpretation, can never be proven.
It then augments the partial interpretation with the negation of the unfounded set, and constructs a new minimal model, treating negated clauses as only true if explicitly present in the new partial interpretation.
This procedure is run unto fixpoint, and produces exactly one well-founded partial model, which will be a subset of all stable models~\cite{wellfounded}.

In our case, stable-set semantics leaves something to be desired due to the potential for no model, and the well-founded approach may return partial solutions.
\subsection{Negation in Holmes}
Traditional Datalog consists only of a head clause, implied by a series of body clauses.
To this, we allow clauses to be optionally negated.
In the original input program, the head clause may not be negated.

As we have no function symbols or interpreted functions, we define a Herbrand universe $\hu$ which is simply the set of constants in the program.
$\hb$ is the set of every predicate instantiated at every combination of values in $\hu$.

We instantiate the program into the Herbrand universe, making a version of each rule with every variable instantiated at every member of $\hu$.
This eliminates pattern matching and reduces all rules to a set of rules of the form
\[
	p \leftarrow \bigwedge q_i \wedge \bigwedge \neg r_j
\]
where $p, q_i, r_i \in \hb$.

For example, if we begin with the program
\begin{align*}
A(x) &\leftarrow B(x) \wedge C(0)\\
B(1) &\leftarrow \neg C(1)\\
B(1) &\leftarrow \neg A(0) \wedge \neg A(1)
\end{align*}

We only see the symbols 0 and 1 present.
This means $\hu = \{0, 1\}$ for this program, and $\hb = \{A(0), A(1), B(0), B(1), C(0), C(1)\}$.
Instantiating all variables in the program at all possible values from $\hu$, we get a variable-free version:
\begin{align*}
A(0) &\leftarrow B(0) \wedge C(0)\\
A(1) &\leftarrow B(1) \wedge C(0)\\
B(1) &\leftarrow \neg C(1)\\
B(1) &\leftarrow \neg A(0) \wedge \neg A(1)\\
\end{align*}
We can now remove parameters from predicates by assigning a name to each member of $\hb$.
\begin{align*}
p &\leftarrow q \wedge r\\
s &\leftarrow t \wedge r\\
t &\leftarrow \neg u\\
t &\leftarrow \neg p \wedge \neg s\\
\end{align*}
Now the program is in the general form described above.

In derived forms, we also allow rules of the form
\[
	\neg p \leftarrow
\]
which simply asserts $\neg p$.
We do not allow rules of this form in the initial program to ensure that the initial program is not directly contradictory.
We will use $N$ to describe a possibly negated term, e.g. it has form $p$ or $\neg p$ where $p \in \hb$.

For a program $\Pi$ which consists of a set of such rules,
\[
	\infer[\textrm{m.p.}]{\Pi \models N_0}{N_0 \leftarrow \bigwedge_{i \in I} N_i \in \Pi & \forall i \in I. \Pi \models N_i}
\]

We will define an interpretation of negation in such programs via a Kripke frame.
We say a program $\Pi$ is consistent if it does not model both truth and falsehood for a single fact.
\[
	\infer[\textrm{consistent}]{\cons{\Pi}}{\forall p \in \hb(\Pi). \Pi \models p \imp \Pi \not \models \neg p}
\]
We say a program $\Pi$ decides a fact if it models it as either true or false.
\[
	\infer[\textrm{decide-true}]{\Pi \decides p}{\Pi \models p}
	\quad
	\infer[\textrm{decide-false}]{\Pi \decides p}{\Pi \models \neg p}
\]

Now, we are equipped to describe our Kripke frame.
A program which decides all predicates and is not inconsistent is a world.
\[
	\infer[\textrm{world-base}]{\world{\Pi}}{\cons{\Pi} & \forall p \in \hb(\Pi). \Pi \decides p}
\]
Any program which is a subset of a world is a world.
\[
	\infer[\textrm{world-subs}]{\world{\Pi}}{\world{\Pi'} & \Pi \subseteq \Pi'}
\]
We define a relation between worlds $\stepass$ describing assumptions that may be made from a given program.
\[
	\infer[\textrm{assume-false}]{\Pi \stepass \Pi \cup (\neg p \leftarrow)}{p \in \hb(\Pi) & \Pi \not \decides p & \world{\Pi \cup (\neg p \leftarrow)}}
\]
\[
	\infer[\textrm{assume-true}]{\Pi \stepass \Pi \cup (p \leftarrow)}{p \in \hb(\Pi) & \Pi \not \decides p & \world{\Pi \cup (p \leftarrow)} & \neg \world{\Pi \cup (\neg p \leftarrow)}}
\]
We complete the Kripke frame by defining the accessibility as transitive closure over $\stepass$.
\[
	\infer[\textrm{refl}]{\Pi \leq \Pi}{}
	\quad
	\infer[\textrm{assume}]{\Pi_0 \leq \Pi_2}{\Pi_0 \leq \Pi_1 & \Pi_1 \stepass \Pi_2}
\]

We consider a formula $F$ true for an input program $\Pi$ if $\Pi \models \dia  F$ under this frame.
Here, $\dia$ means ``possibly'', so this condition says that it is possibly the case that this formula holds.
We can visualize this on a directed graph with worlds as nodes and and the single-step form of our accessibility relation ($\stepass$) as an edge.
This condition means that if we start from $\Pi$, our input program, we can find a connected program $\Pi'$, so that no matter what path we take forwards from there, the formula $F$ holds.
Conceptually, this means that there exists an allowed choice of assumptions so that $F$ holds.

\subsubsection{Example}
Consider the program we herbrandized previously, extended with the initial EDB $\{r\}$, calling the initial program $\Pi_0$.
Initially, we have that $\Pi_0 \models r$
We cannot derive any more from $\Pi_0$ because $r$ is not sufficient to invoke any rule through m.p.
We proceed by considering a candiate world $\Pi_1 = \Pi_0 \cup \{\neg u \leftarrow\}$.
Through iterative application of m.p. we get
\[
\Pi_1 \models r \wedge \neg u \wedge t \wedge s
\]
$p$ and $q$ are still undecided, so we create candidate worlds
\[\Pi_2 = \Pi_1 \cup \{\neg p \leftarrow\}\]
\[\Pi_3 = \Pi_2 \cup \{\neg q \leftarrow\}\]
At $\Pi_3$, we have through iterative application of m.p.
\[
\Pi_3 \models \neg p \wedge \neg q \wedge r \wedge s \wedge t \wedge \neg u
\]
As a result, for all each predicate, $\Pi_3$ decides it, e.g. $\Pi_3 \decides p$, $\Pi_3 \decides q$, etc. either through decides-true or decides-false depending on its negation in the earlier formula.
Specifically,
\[
\forall p \in \hb(\Pi_3). \Pi_3 \decides p
\]
Since $\Pi_3$ only derives the truth of $r, s, t$, and does not derive any of their negation, by the consistent rule we have $\cons{\Pi_3}$.
With these combined, we can apply the world-base rule and get $\world{\Pi_3}$.
By world-subset, $\Pi_0, \Pi_1, \Pi_2$ are all worlds as they are subsets of $\Pi_3$.

We focus on the accessibility relation next.
If we apply assume-false to $\Pi_3$ and the predicate q, we get $\Pi_2 \stepass \Pi_3$.
Repeatedly applying it yields
\[
	\Pi_0 \stepass \Pi_1 \stepass \Pi_2 \stepass \Pi_3
\]
Starting with refl on $\Pi_0$, we get $\Pi_0 \leq \Pi_0$.
Iteratively applying assume, we get that $\Pi_0 \leq \Pi_3$.

Now we combine this information to show that what $\Pi_3$ models is a legal output for the input program.
Recall that
\[
	\Pi_3 \models \neg p \wedge \neg q \wedge r \wedge s \wedge t \wedge \neg u
\]
Since $\Pi_0 \leq \Pi_3$, we can additionally say that the above formula is possible at $\Pi_0$.
\[
	\Pi_0 \models \dia (\neg p \wedge \neg q \wedge r \wedge s \wedge t \wedge \neg u)
\]

\subsubsection{call/cc}
Adding the assume-true rule is what differentiates our negation model.
This rule only allows the assumption of truth if assuming false would either make the world inconsistent immediately, or make it impossible to provide a consistent assignment to the remainder of the facts given that assumption.
By adding assume-true, we allow a consistent solution in the presence of negation in some cases it would not otherwise be possible.
By restricting it to those cases where assuming falsehood would result in a forced inconsistency in any complete model, we still rule out trivial solutions like setting everything true, but in a looser way than the minimal model over the reduct.
It is looser because it allows for models which are not minimal over the reduct, as when assume-true is used, it adds a true proposition which has no derivation from the rules, and so would not be present in any minimal model.
As assume-true is only allowed in cases where assume-false would lead to no solution, it still prohibits the trivial solution (all predicates are in the model).

\subsubsection{How Negations Differ}
We consider the program consisting only of the rule $P \leftarrow \neg P$ to concretely examine the difference between these negation strategies.

In the case of a stable-set semantics, this can have no model.
The only two candidate models are $\{P\}$ or $\emptyset$.
Under the first model, the rule is not satisfied, so the reduct is the empty program.
This reduct does not support $P$, and so it is not a minimal model, and not a stable set.
Under the second model, the reduct is $P \leftarrow$, and so it is not a model of the reduct because $P$ must hold.

%TODO add to background precise description of well-founded negation
Under well-founded negation, the unfounded set is empty, because $P$ still appears on the left hand side of the rule.
As a result, evaluation terminates immediately.
Well-founded negation returns the \emph{partial model} $\emptyset$.

Following our negation system, we begin with
\[\Pi = \{P \leftarrow \neg P\}\]
Now, we define two candidate worlds,
\[\Pi^- = \Pi \cup \{\neg P \leftarrow\}\]
\[\Pi^+ = \Pi \cup \{P \leftarrow\}\]
In the case of $\Pi^-$, we have both $\Pi^- \models P$ and $\Pi^- \models \neg P$, so $\neg \cons{\Pi^-}$.
As a result, $\neg W(\Pi^-)$.
For $\Pi^+$, we have only that $\Pi^+ \models P$, so $\cons{\Pi}$.
Since $P$ is the totality of $\hb{\Pi^+}$, $W(\Pi^+)$ by world-base.
By world-subset, $W(\Pi)$.
We can apply assume-true, using $W(\Pi^+)$, $\neg W(\Pi^-)$, and that $\Pi$ does not decide $P$.
This gives $\Pi \stepass \Pi^+$.
Finally
\[
	\Pi^+ \models P
\]
Since $\Pi \stepass \Pi^+$, by refl and assume $\Pi \leq \Pi^+$, so
\[
	\Pi \models \dia P
\]

This simple example shows the differences between the approaches.
In the face of this kind of uncertainty, stable-set semantics will choose not to give an answer, well-founded semantics will not decide either way, and circumscriptive semantics will make concessions to return a consistent complete answer. 

In Holmes, circumscription corresponds to a potentially-infinite variety of assume-false in which every version of a specific aggregate greater than the proposed circumscription is negated.
call/cc corresponds to assume-true, but is a bit more complex, since it needs to discern at least one specific assumption from the infinite negation arm which is untenable.

\section{Herbrandization}
\label{formal:sec:herbrand}
First, we define the Herbrand universe and base.
Then, we describe how to instantiate a Holmes program at this universe.

\subsection{Herbrand universe}
\label{formal:sec:callbacks}
Instead of function symbols which produce new values, as in a traditional construction, we have interpreted functions and and lattice joins.
This is different from the normal construction because interpreted functions both interpreted functions and lattice meets may produce values which are equal to existing values.
To address the equality issue, we assume that our construction is supplied with implementations of the callbacks and join operations as the real program would, and actually execute them on input values rather than creating symbolic expansions.

Define $U_0$ to be those constants present in the program, combined with varieties tupled up to the maximum arity of the provided functions.
Consider joins as equivalent to callbacks which just happen to return only one argument.
Let $F$ be the set of functions, modified to take tuples for multiple arguments, and to return their results ``flattened'', e.g. if a callback would return $a = 1, b = 2$ and $a = 3, b = 4$, its representative in $F$ returns $\{1, 2, 3, 4\}$.
Since both meets and callbacks are typed, if an input would be outside their domain, they return $\emptyset$.

Given $U_i$, construct $U_{i + 1}$ by
\[
	U_{i + 1} = \bigcup_{x \in U_i, f \in F} f(x)
\]
We then combine these stages:
\[
	\hu = \lim_{j \rightarrow \infty} \bigcup_{0 \leq i < j} U_i
\]

The Herbrand base $\hb$ is constructed in the usual way, instantiating each predicate at every value of $\hu$.

\subsection{Program Instantiation}
For predicates which have aggregation, rewrite them as rules with interpreted functions.
If we have
\[
	P(\tau_0 \cdots \tau_m, \sigma_0\wedge j_0 \cdots \sigma_n \wedge j_n)
\]
then we create a new function
\[
	j(a_0 \cdots a_n, b_0 \cdots b_n) = \{c_0 = j_0(a_0, b_0) \cdots c_n = j_n(a_n, b_n)\}
\]
and add the rule
\[
	P(x_0 \cdots x_m, c_0 \cdots c_n) \leftarrow P(x_0 \cdots x_m, a_0 \cdots a_n), P(x_0 \cdots x_m, b_0 \cdots b_n) + j
\]
where $+ j$ as in the informal Holmes description means to attach the function $j$ to run after the match to generate a set of assignments to variables in the head clause not bound by the body.
For each aggregated predicate, introduce a circumscripted version of the predicate, $P_c$.
Perform simple replacement of all circumscripted matches to $P$ with matches against $P_c$.

Now, the program looks like normal Datalog but with functions attached to some rules.
For every element of the Herbrand universe, instantiate the rule, run the function concretely on the variables bound in the body clause, and instantiate the head term.
This will result in a rules of the form
\[
	p \leftarrow \bigwedge q_i
\]
where $p, q_i \in \hb$.

\section{Semantics}
\label{formal:sec:semantics}
We begin by defining a few extra sets relative to the initial program which will be needed for interpretation.
Let $\circset(\Pi) \subseteq \hb(\Pi)$ be the set of circumscripted facts added, e.g. they were of the form $P_c(\cdot)$.

Let $\aggset(\Pi)$ be a set of tuples of an aggregated predicate and all of its non-aggregated inputs.
For example, for $P(x_0, \cdots x_n, y_0, \cdots y_m)$ and all $y$ are aggregated, $(P, x_0, \cdots x_n)$ for each possible value of $x_0$ through $x_n$ would be present in $\aggset(\Pi)$.
We will refer to members of $\aggset(\Pi)$ as ``aggregates''.

Let $\circset_a(\Pi)$ where $a \in \aggset(\Pi)$ be the set of circumscriptions which correspond to that aggregation specifically.
This is a partitioning of $\circset(\Pi)$.

Let $\decirc{\Pi}{c}$ where $c \in \circset(\Pi)$ be the non-circumscribed version of the fact, e.g. if $c$ corresponds to $P_c(x_0 \cdots x_n)$, then $\decirc{\Pi}{c} \in \hb$ corresponds to $P(x_0 \cdots x_n)$.

Let $\viol{\Pi}{c} \subseteq \hb$ be those predicates which are \emph{directly} negated by the circumscription.
This contains all of those values belonging to the same aggregate which are not less than or equal to the circumscription.


Much of this is similar to the simple negation semantics, but I restate it here for clarity.

\[
	\infer[\textrm{consistent}]{\cons{\Pi}}{\forall c \in \circset(\Pi). \Pi \models c \imp ((\forall p \in \viol{\Pi}{c}. \Pi \not \models p) \wedge \Pi \models \decirc{\Pi}{c})}
\]
Like previously, consistency here requires that a none of the negations assumed by a circumscription also be present in the model in a non-negated form.
Specifically, the rule says that for all circumscripted facts in the universe, if they are in the model of the program, then none of the conditions which would violate the circumscription hold, and the aggregated fact corresponding to the circumscripted fact holds.
Additionally, the circumscription must be supported: the aggregate must have reached the point on the lattice that the circumscription asserts will be the exact value.

Rather than deciding individual facts as we did previously, we now decide aggregates.
\[
	\infer[\textrm{bounded}]{\Pi \decides a}{c \in \circset_a(\Pi) & \Pi \models c}
	\quad
	\infer[\textrm{no-base}]{\Pi \decides a}{\forall c \in \circset_a(\Pi). \Pi \not \models \decirc{\Pi}{c}}
\]
The bounded case indicates that we have circumscribed this aggregate, and so have decided it.
The no-base case indicates that this aggregate is totally unpopulated by the program.
Since our lattices are not guaranteed to be bounded, no circumscription can be made.
As we cannot circumscribe over it, we are considered to decide the aggregate.
Specifically, the program has decided on the negation of all values which could make up the aggregate.

This time, since our $\stepass$ is more complex, our world predicate and $\stepass$ are defined mutually recursively.
We also index $\stepass$ with the aggregate that it either circumscribes or extends.

\[
	\infer[\textrm{world}]{\world{\Pi}}{\forall a \in \aggset(\Pi). \Pi \decides a \vee \exists \Pi'. \Pi \stepass_a \Pi'}
\]
A program is a world if for every aggregate, it either decides it, or there is a one-step accessibility to one where it is circumscribed or extended ($\stepass_a$).

\[
	\infer[\textrm{circ}]{\Pi \stepass_a \Pi \cup c}{\Pi \not \decides a & c \in \circset_a(\Pi) & W(\Pi \cup c)}
\]
If $a$ isn't decided yet, and circumscribing it closed would not cause any inconsistency, we may do it.

For call/cc, let $\Pi_c$ be $\Pi$, but modified so that $\viol{\Pi}{c} = \emptyset$ and $c$ is unioned in.
In other words, $\Pi_c$ is $\Pi \cup c$, but will ignore inconsistencies which are based on the addition of $c$.
\[\small
	\infer[\textrm{call/cc}]{\Pi \stepass_a \Pi \cup p}{\Pi \not \decides a & \world{\Pi_c} & \not \exists c'. \Pi \stepass_a \Pi' \cup c' & \not \exists p' \in \viol{\Pi}{c}. \Pi \models p' & p \in \viol{\Pi}{c} & \Pi_c \models \dia p}
\]
This rule says that if we cannot construct $\stepass_a$ using the circ rule, but $\Pi_c$ would extend the aggregate $a$ with new information, then we can extend $a$ with the new information even though the proposed circumscription would not result in a world.
We define $\leq$ based on $\stepass$ exactly as before.

Finally, we hold a formula to be true for a Holmes program if the program $\Pi$ it is translated into can access a world where all accessible worlds can access a world where the formula is true. More succinctly, $\Pi \models \dia F$.
