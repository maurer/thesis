\section{Future Work}
There are a wide variety of ways to extend this work, and that is where part of the beauty of the system lies. %TODO more introybullshit

One improvement would be to use REWARDS style type sourcing for the system call boundary and for dynamically-linked libraries with publicly known APIs. This would provide more human readable names and types of unused fields on top of what is already present. Combining these systems in this way would not likely improve static analysis capabilities of the system substantially, but would likely improve the quality of decompiler output. As a result, this combination could transform the system into an even higher quality reverse engineering tool.

Another potential improvement is to instead of just focusing on a most general unifier, also augment the system with principal typings, allowing the typing procedure to be done primarily compositionally rather than as a constraint solving problem. While this might sound like just an implementation detail, such a modification would allow parallelization of the algorithm along with re-use of previously inferred type constraints if done correctly. This would allow for incremental inference of portions of code, re-use of analysis of a pre-patch binary to analyze a post-patch binary, and greater scaling ability to analyze larger pieces of software.

While the type system as it stands has a ``code'' type, it currently uses the SSA form BAP lifts the code to in order to know that it is capturing the type dependencies of such a jump. If a more fully described code type were added to the system, this would add the potential to operate on non-SSA lifted code, allowing the it to deal with the inference of code for which it is difficult to predict the target of a jump. Indeed, iterative analysis of this form might be usable to do some amount of jump target resolution - if one can verify that the jump is legal, then one has restricted the number of legal targets drastically.

Another avenue for extension is the examination of Stack TAL[cite], Rust's borrowing system[cite], and other similar work to attempt to add some amount of safety over allocations. This kind of augmentation is vital to actually being able to guarantee any kind of safety about a piece of code using this system. Without it, the system can only say that it's safe modulo use-after-free style bugs, whether they be stack or heap. This is, however, trickier than it looks, as previous systems have found ways to construct code that can be checked in this way, while an extension here would need to find a way to check code written in what is likely usually a more liberal way.

Along similar lines, the arrays in the current system are not safe unless they are a statically sized array whose size is trivially statically determinable. It would be nice to extend basic dependent typing to the system to provide safety, but as with the use-after-free issues, this kind of extension cannot follow traditional methods due to a slightly different problem area. In a traditional dependent type system, the burden is placed on the programmer to prove that the values of types are as they need to be. Here, the system will have to do this automatically, or possibly work interactively with a reverse engineer to construct these proofs. Additionally, as part of the reason that the burden is usually on the user of the tool, most sufficiently dependent type systems are undecidable, which means that any machine-only implementation will necessarily have flaws.

Most of the nice properties about there definitely existing a type for safe code breaks down in the presence of unions. Adding disjoint unions (those where the two types take on distinct ranges, and so can inherently be branched on, such as null pointers) and tagged unions (those where a nearby tag is associated with the data, and when branched on, such as a boxed number with a flag determining whether it is an integer or a float) would largely remedy this issue, and simultaneously add support for the notion of non-nullable pointer, which would enhance the descriptive and safety properties of the system.

Lastly, the kind of structural and recursive type extraction present here would, in combination with the code extension suggested above, lay the groundwork for C++ type inference. Subtyping can describe inheritance structures well; the enhanced code type can be used for purposes of describing the vtables appropriately. With those and the data-structure friendly type system present here, class detection and type inference would likely be possible.
